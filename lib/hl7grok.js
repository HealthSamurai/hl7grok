// Generated by CoffeeScript 1.10.0
(function() {
  var coerce, fs, getMeta, parse, parseComponents, parseFields, parseSegments, parseSubComponents, replaceBlanksWithNulls;

  fs = require("fs");

  replaceBlanksWithNulls = function(array) {
    return array.map(function(v) {
      if (v && v.trim().length > 0) {
        return v;
      } else {
        return null;
      }
    });
  };

  getMeta = function(hl7version) {
    return JSON.parse(fs.readFileSync(__dirname + ("/../meta/v" + (hl7version.replace('.', '_')) + ".json")));
  };

  coerce = function(value, typeId) {
    return value;
  };

  parse = function(msg) {
    var hl7version, messageType, meta, msh, segments, separators;
    if (msg.substr(0, 4) !== "MSH|") {
      throw new Error("Message should start with MSH segment");
    }
    if (msg.length < 8) {
      throw new Error("Message is too short (MSH truncated)");
    }
    separators = {
      segment: "\r",
      field: msg[3],
      component: msg[4],
      subcomponent: msg[7],
      repetition: msg[5],
      escape: msg[6]
    };
    segments = msg.split(separators.segment).map(function(s) {
      return s.trim();
    });
    segments = segments.filter(function(s) {
      return s.length > 0;
    });
    msh = segments[0].split(separators.field);
    messageType = msh[8];
    hl7version = msh[11];
    meta = getMeta(hl7version);
    return parseSegments(segments, meta, separators);
  };

  parseSegments = function(segments, meta, separators) {
    var i, len, rawFields, result, segment, segmentName;
    result = {};
    for (i = 0, len = segments.length; i < len; i++) {
      segment = segments[i];
      rawFields = segment.split(separators.field);
      segmentName = rawFields.shift();
      result[segmentName] = parseFields(rawFields, segmentName, meta, separators);
    }
    return result;
  };

  parseFields = function(fields, segmentName, meta, separators) {
    var fieldId, fieldIndex, fieldMax, fieldMeta, fieldMin, fieldValue, fieldValues, i, len, ref, result, segmentMeta, splitRegexp;
    segmentMeta = meta.SEGMENTS[segmentName];
    result = [segmentName];
    if (segmentMeta[0] !== "sequence") {
      throw new Error("Bang! Unknown case: " + segmentMeta[0]);
    }
    for (fieldIndex = i = 0, len = fields.length; i < len; fieldIndex = ++i) {
      fieldValue = fields[fieldIndex];
      fieldMeta = segmentMeta[1][fieldIndex];
      if (fieldMeta) {
        fieldId = fieldMeta[0];
        ref = fieldMeta[1], fieldMin = ref[0], fieldMax = ref[1];
        if (fieldMin === 1 && (!fieldValue || fieldValue === '')) {
          throw new Error("Missing value for required field: " + fieldId);
        }
        splitRegexp = new RegExp("(?!\\" + separators.escape + ")" + separators.repetition);
        fieldValues = fieldValue.split(splitRegexp).map(function(v) {
          return parseComponents(v, fieldId, meta, separators);
        });
        if (fieldMax === 1) {
          result.push(fieldValues[0]);
        } else if (fieldMax === -1) {
          result.push(fieldValues);
        } else {
          throw new Error("Bang! Unknown case for fieldMax: " + fieldMax);
        }
      } else {
        result.push(fieldValue);
      }
    }
    return result;
  };

  parseComponents = function(value, fieldId, meta, separators) {
    var fieldMeta, fieldType, splitRegexp, typeMeta;
    fieldMeta = meta.FIELDS[fieldId];
    if (fieldMeta[0] !== 'leaf') {
      throw new Error("Bang! Unknown case for fieldMeta[0]: " + fieldMeta[0]);
    }
    fieldType = fieldMeta[1];
    typeMeta = meta.DATATYPES[fieldType];
    if (typeMeta) {
      splitRegexp = new RegExp("(?!\\" + separators.escape + ")\\" + separators.component);
      return value.split(splitRegexp).map(function(c, index) {
        var componentId, componentMax, componentMin, ref;
        componentId = typeMeta[1][index][0];
        ref = typeMeta[1][index][1], componentMin = ref[0], componentMax = ref[1];
        if (componentMin === 1 && (!c || c === '')) {
          throw new Error("Missing value for required component " + componentId);
        }
        if (componentMax === -1) {
          throw new Error("Bang! Unlimited cardinality for component " + componentId);
        }
        return parseSubComponents(c, componentId, meta, separators);
      });
    } else {
      return value;
    }
  };

  parseSubComponents = function(v, scId, meta, separators) {
    var scMeta;
    scMeta = meta.DATATYPES[scId];
    if (scMeta) {
      if (scMeta[0] !== 'leaf') {
        throw new Error("Bang! Unknown case for scMeta[0]: " + scMeta[0]);
      }
      return coerce(v, scMeta[1]);
    } else {
      return v;
    }
  };

  module.exports = {
    grok: parse
  };

}).call(this);
