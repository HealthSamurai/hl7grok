// Generated by CoffeeScript 1.10.0
(function() {
  var _structurize, coerce, deprefixGroupName, fs, getMeta, parse, parseComponents, parseFields, parseSegments, parseSubComponents, replaceBlanksWithNulls, structurize;

  fs = require("fs");

  replaceBlanksWithNulls = function(v) {
    var a, b, res;
    if (Array.isArray(v)) {
      return v.map(function(b) {
        return replaceBlanksWithNulls(b);
      });
    } else if (typeof v === 'object') {
      res = {};
      for (a in v) {
        b = v[a];
        res[a] = replaceBlanksWithNulls(b);
      }
      return res;
    } else if (typeof v === 'string' && v.trim().length <= 0) {
      return null;
    } else {
      return v;
    }
  };

  getMeta = function(hl7version) {
    return JSON.parse(fs.readFileSync(__dirname + ("/../meta/v" + (hl7version.replace('.', '_')) + ".json")));
  };

  deprefixGroupName = function(name) {
    return name.replace(/^..._.\d\d_/, '');
  };

  coerce = function(value, typeId) {
    return value;
  };

  _structurize = function(meta, struct, message, segIdx) {
    var collectedSegments, expSegMax, expSegMin, expSegName, newSegIdx, ref, ref1, result, structIdx, subResult, thisSegName;
    if (struct[0] !== 'sequence') {
      throw new Error("struct[0] != sequence, don't know what to do :/");
    }
    result = {};
    structIdx = 0;
    while (true) {
      expSegName = struct[1][structIdx][0];
      ref = struct[1][structIdx][1], expSegMin = ref[0], expSegMax = ref[1];
      collectedSegments = [];
      thisSegName = null;
      while (true) {
        thisSegName = message[segIdx][0];
        if (collectedSegments.length === expSegMax && expSegMax === 1) {
          break;
        }
        if (meta.GROUPS[expSegName]) {
          ref1 = _structurize(meta, meta.GROUPS[expSegName], message, segIdx), subResult = ref1[0], newSegIdx = ref1[1];
          if (subResult !== null) {
            segIdx = newSegIdx;
            collectedSegments.push(subResult);
          } else {
            break;
          }
        } else {
          if (thisSegName === expSegName) {
            collectedSegments.push(message[segIdx]);
            segIdx = segIdx + 1;
          } else {
            break;
          }
        }
      }
      if (collectedSegments.length === 0) {
        if (expSegMin === 1) {
          console.log("Expected segment " + expSegName + ", got " + thisSegName + " at segment index " + segIdx);
          return [null, segIdx];
        }
      } else {
        if (expSegMax === 1) {
          result[deprefixGroupName(expSegName)] = collectedSegments[0];
        } else {
          result[deprefixGroupName(expSegName)] = collectedSegments;
        }
      }
      structIdx += 1;
      if (structIdx >= struct[1].length) {
        break;
      }
    }
    if (Object.keys(result).length === 0) {
      return [null, segIdx];
    } else {
      return [result, segIdx];
    }
  };

  structurize = function(meta, message, messageType) {
    var foo, ref, result;
    ref = _structurize(meta, meta.MESSAGES[messageType.join("_")], message, 0), result = ref[0], foo = ref[1];
    return result;
  };

  parse = function(msg) {
    var hl7version, message, messageType, meta, msh, segments, separators;
    if (msg.substr(0, 3) !== "MSH") {
      throw new Error("Message should start with MSH segment");
    }
    if (msg.length < 8) {
      throw new Error("Message is too short (MSH truncated)");
    }
    separators = {
      segment: "\r",
      field: msg[3],
      component: msg[4],
      subcomponent: msg[7],
      repetition: msg[5],
      escape: msg[6]
    };
    segments = msg.split(separators.segment).map(function(s) {
      return s.trim();
    });
    segments = segments.filter(function(s) {
      return s.length > 0;
    });
    msh = segments[0].split(separators.field);
    messageType = msh[8].split(separators.component);
    hl7version = msh[11];
    meta = getMeta(hl7version);
    message = parseSegments(segments, meta, separators);
    message = structurize(meta, message, messageType);
    return message;
  };

  parseSegments = function(segments, meta, separators) {
    var i, len, rawFields, result, segment, segmentName;
    result = [];
    for (i = 0, len = segments.length; i < len; i++) {
      segment = segments[i];
      rawFields = segment.split(separators.field);
      segmentName = rawFields.shift();
      result.push(parseFields(rawFields, segmentName, meta, separators));
    }
    return result;
  };

  parseFields = function(fields, segmentName, meta, separators) {
    var fieldId, fieldIndex, fieldMax, fieldMeta, fieldMin, fieldSymbolicName, fieldValue, fieldValues, i, len, otherFieldMeta, ref, result, segmentMeta, splitRegexp;
    segmentMeta = meta.SEGMENTS[segmentName];
    result = {
      "0": segmentName
    };
    if (segmentMeta[0] !== "sequence") {
      throw new Error("Bang! Unknown case: " + segmentMeta[0]);
    }
    for (fieldIndex = i = 0, len = fields.length; i < len; fieldIndex = ++i) {
      fieldValue = fields[fieldIndex];
      fieldMeta = segmentMeta[1][fieldIndex];
      otherFieldMeta = meta.FIELDS[fieldMeta[0]];
      fieldSymbolicName = otherFieldMeta[2];
      if (fieldMeta) {
        fieldId = fieldMeta[0];
        ref = fieldMeta[1], fieldMin = ref[0], fieldMax = ref[1];
        if (fieldMin === 1 && (!fieldValue || fieldValue === '')) {
          throw new Error("Missing value for required field: " + fieldId);
        }
        splitRegexp = new RegExp("(?!\\" + separators.escape + ")" + separators.repetition);
        fieldValues = fieldValue.split(splitRegexp).map(function(v) {
          return parseComponents(v, fieldId, meta, separators);
        });
        if (fieldMax === 1) {
          result[fieldIndex + 1] = fieldValues[0];
        } else if (fieldMax === -1) {
          result[fieldIndex + 1] = fieldValues;
        } else {
          throw new Error("Bang! Unknown case for fieldMax: " + fieldMax);
        }
      } else {
        result[fieldIndex + 1] = fieldValue;
      }
      if (segmentName === 'MSH') {
        result[fieldSymbolicName] = result[fieldIndex];
      } else {
        result[fieldSymbolicName] = result[fieldIndex + 1];
      }
    }
    return replaceBlanksWithNulls(result);
  };

  parseComponents = function(value, fieldId, meta, separators) {
    var fieldMeta, fieldType, splitRegexp, typeMeta;
    fieldMeta = meta.FIELDS[fieldId];
    if (fieldMeta[0] !== 'leaf') {
      throw new Error("Bang! Unknown case for fieldMeta[0]: " + fieldMeta[0]);
    }
    fieldType = fieldMeta[1];
    typeMeta = meta.DATATYPES[fieldType];
    if (typeMeta) {
      splitRegexp = new RegExp("(?!\\" + separators.escape + ")\\" + separators.component);
      fieldMeta = "^";
      return [fieldMeta].concat(value.split(splitRegexp).map(function(c, index) {
        var componentId, componentMax, componentMin, ref;
        componentId = typeMeta[1][index][0];
        ref = typeMeta[1][index][1], componentMin = ref[0], componentMax = ref[1];
        if (componentMin === 1 && (!c || c === '')) {
          throw new Error("Missing value for required component " + componentId);
        }
        if (componentMax === -1) {
          throw new Error("Bang! Unlimited cardinality for component " + componentId);
        }
        return parseSubComponents(c, componentId, meta, separators);
      }));
    } else {
      return coerce(value, fieldType);
    }
  };

  parseSubComponents = function(v, scId, meta, separators) {
    var scMeta;
    scMeta = meta.DATATYPES[scId];
    if (scMeta) {
      if (scMeta[0] !== 'leaf') {
        throw new Error("Bang! Unknown case for scMeta[0]: " + scMeta[0]);
      }
      return coerce(v, scMeta[1]);
    } else {
      return v;
    }
  };

  module.exports = {
    grok: parse
  };

}).call(this);
